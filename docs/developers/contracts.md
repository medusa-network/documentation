---
sidebar_position: 3
---

# Contracts

There are two main important contracts to know when interacting with Medusa:
* the "oracle" contract to submit ciphertexts, reencryption request and receive results
* the "client" interface that defines how Medusa can submit the result back

The interface for both of these contracts are defined in this solidity [file](https://github.com/medusa-network/medusa-contracts/blob/main/src/EncryptionOracle.sol).

But first, we need to explore the core structure of what Medusa handle: encrypted data.

## Encryption & Reencryption

There are two notions of encrypted data in Medusa:
* **Encryption**: a `Ciphertext` is some encrypted data created by the client and submitted to Medusa. Any ciphertext can be denoted by its id, a `uint256 _cipherId`.
* **Reencryption**: a `ReencryptedCipher` is a reencryption of a `Ciphertext`, created by Medusa and submitted onchain.

```solidity
/// A 32-byte encrypted ciphertext that a client submits to Medusa
struct Ciphertext {
    G1Point random;
    uint256 cipher;
    /// DLEQ part
    G1Point random2;
    DleqProof dleq;
}

/// Struct that Medusa nodes submits in response to a request
struct ReencryptedCipher {
    G1Point random;
    uint256 cipher;
}
```

## Oracle contract

Here is a simplified version of the interface, enough to define the ABI to communicate with it:

```solidity
interface IEncryptionOracle {
    /// @notice submit a ciphertext and has been created by the encryptor address.
    /// The ciphertext proof is checked and if correct, will be signalled to Medusa.
    function submitCiphertext(Ciphertext calldata _cipher, address _encryptor) external returns (uint256);
    /// @notice requests the Medusa nodes to reencrypt the ciphertext denoted by _cipherId
    /// to the publickey given.
    function requestReencryption(uint256 _cipherId, G1Point calldata _publickey) external payable returns (uint256);
}
````

### Client submission

The first method is to signal to Medusa that a ciphertext
has been submitted. Medusa nodes don't "store" it but will pick up the event later when a reencryption request is sent. The return value is the cipher id generated by Medusa. It is a unique ID amongst all ciphertexts ever submitted 
on this platform.

###Â Reencryption request

One needs to specify the cipher ID that one wants the 
reencryption of, and the publickey to which to reencrypt. See sections about encryption & decryption to learn more about the public key. It returns an unique 
request ID. This request ID will be used later when Medusa submits the reencryption, so the dApp knows which reencryption request it is related to.

## Client contract

This interface contract is what any dApp must implement to be able to receive
the results from Medusa:
```solidity
interface IEncryptionClient {
    /// @notice Callback to client contract when medusa posts a result
    /// @dev Implement in client contracts of medusa
    /// @param requestId The id of the original request
    /// @param _cipher the reencryption result
    function oracleResult(uint256 requestId, ReencryptedCipher calldata _cipher) external;
}
```

Medusa will call this function giving the relevant request id and the result. 
The dApp is free to handle the reencrypted ciphertext in any way it wants.
Generally we recommend to emit an event so the client can simply listen off the 
events from the dApp to get back the reencryption.