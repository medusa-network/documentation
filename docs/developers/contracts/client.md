---
sidebar_position: 3
---

# Client contract

You must inherit the `MedusaClient` contract to be able to receive the callback that contains the reencrypted content for the user.

See below an example for a private blog on how to integrate:

```solidity

contract MyApplication is MedusaClient {

    event NewPost(uint256 requestId, ReencryptedCipher memory _cipher);

    constructor(EncryptionOracle _oracle) MedusaClient(_oracle) 
    {
        // application logic constructor here
    }

    // requestId is an ID generated by Medusa when requesting a reencryption.
    // cipher is the actual key material necessary for the end user to read the encrypted content.
    // Note this key material is private to the recipient, only him can decrypt it.
    function processOracleResult(uint256 _requestId, ReencryptedCipher memory _cipher)
        internal
        view
        override
    {
        // New post has been emitted, the recipient listens for the post encrypted towards
        // his own public key.
        emit NewPost(_requestId, _cipher);
    }
}
```

Medusa will call the `processOracleResult` function giving the relevant request id and the result. 
The request ID comes from the actual request made to the oracle contract by the user earlier. See the [relevant documentation](https://docs.medusanet.xyz/developers/contracts/medusa).

The dApp is free to handle the reencrypted ciphertext in any way it wants.
Generally we recommend to emit an event so the client can simply listen off the 
events from the dApp to get back the reencryption.
