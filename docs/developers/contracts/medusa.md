---
sidebar_position: 2
---

# Oracle contract

Here is a simplified version of the interface, enough to define the ABI to communicate with it:

```solidity
interface IEncryptionOracle {
    /// @notice submit a ciphertext and has been created by the encryptor address.
    /// The ciphertext proof is checked and if correct, will be signalled to Medusa.
    function submitCiphertext(Ciphertext calldata _cipher, address _encryptor) external returns (uint256);
    /// @notice requests the Medusa nodes to reencrypt the ciphertext denoted by _cipherId
    /// to the publickey given.
    function requestReencryption(uint256 _cipherId, G1Point calldata _publickey) external payable returns (uint256);
}
```

## Client submission

The first method is to signal to Medusa that a ciphertext
has been submitted. Medusa nodes don't "store" it but will pick up the event later when a reencryption request is sent. The return value is the cipher id generated by Medusa. It is a unique ID amongst all ciphertexts ever submitted 
on this platform.

##Â Reencryption request

One needs to specify the cipher ID that one wants the 
reencryption of, and the publickey to which to reencrypt. See sections about encryption & decryption to learn more about the public key. It returns an unique 
request ID. This request ID will be used later when Medusa submits the reencryption, so the dApp knows which reencryption request it is related to.

